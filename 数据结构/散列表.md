
# 散列表
## 整除余留

为何取模取 90001？  
若取 M = 2^K, 其效果相当于截取 key 的最后 K 位 bit， 前面的 N-K 位对地址没有影响  
M - 1 = 000000...0|1111...1  
key % M = key & (M - 1)  
发生冲突的概率大  

>**此时将M取为*素数*，数据对散列表的覆盖最为*充分*， 分布最为*均匀***  

数据往往具有局部性 (Locality) 具有单调步长 (step)  
最大公因数 ( gcd )  
取 gcd (S, M) = G
空间 M 中从某一点开始，以 S 为间隔分布。  

>**当且仅当散列表的最大公因子 G = 1 时，数据序列的足迹可以遍布整个散列表**  

## MAD法  

除余法的缺陷:  
+ 不动点： 无论表长M取值如何，总有 hash(0) ≡ 0  
+ 零阶均匀：[ 0，R )的关键码，平均分配至M个桶；但**相邻关键码**的散列地址也**必然相邻**  

>MAD = multiply add divided  

取 M 为素数，a > 0, b > 0, a % M ≠ 0  
>hash( key ) = ( a * key + b ) % M  

`b -> offset( 偏移量 ); a -> step ( 步长 )`  

## More  
### *数字分析 selecting digits*  
+ 抽取 key 中的某几位构成地址  

### *平方取中 mid-square*  
+ 取key^2的中间若干位构成地址  
hash( 123 ) = 512 // 保留123^2 = 15129 的中间 3 位  

### *折叠汇总 folding*
+ 将 key 分割成**等宽**的若干段，取其总和作为地址  
hash (123456789) = 1368 // 132+456+789  
### *位异或 XOR*
+ 将 key 分割成**等宽**的二进制段，经异或运算得到地址  
hash(110011011) = 110 // 110^ 011^ 011  

## 伪随机数
### 伪随机数发生器  
+ 循环: rand(x+1) = [a * rand( x )] % M  
a = 7^5 =16807 = 100000110100111  

### 伪随机数法  
+ 径取: hash(key) = rand(key) = [rand(0) * a^key] % M  
种子: rand(0) = ?  

***!!!可移植性差!!!***  

## 多项式法  

### hash( s = *x0x1x2x3...xn-1* (由X1 - n-1 组成的字符串) ) = x0\*a^n-1 + x1\*a^n-2 + ... + xn-2\*a^1 + xn-1  
-----时间复杂度O(n)  
```
static size_t hashCode( char s[] ) {
    int h = 0;
    for ( size_t n = strlen(s), i = 0; i < n; i++ )
    {
        h = (h << 5) | ( h >> 27 );
        h += (int) s[i];
    }
    return (size_t) h;
}
```  

# 散列冲突  

## 多槽位  multiple slots  
将桶单元分成若干槽位 **slot** 来存放同一单位冲突的词条  
`只要槽位数目不多，依然可以保证O(1)的效率`  

## 独立链  ：封闭定址 closed addressing
linked-list chaining / separate chaining  

每个桶存放一个指针，将冲突的词条组织成列表  
缺点： 
+ 指针需要额外空间，节点需要动态申请  
+ 空间未必连续，系统缓存几乎失效

## open addressing  ~ closed hasing

为每个捅都事先约定若干备用桶  
它们构成一个**查找链** probing sequence / chain  
### 线性试探 linear probing  
一旦冲突，则试探后一紧邻桶单元  

缺点： 排解先前的冲突容易引发后续冲突  


### 懒惰删除 lazy removal  ----至优方案
仅作删除标记，查找链不必续接  
标记删除后，若查找到删除标记，直接将值置入  

## 平方试探 quadratic probing  
以平方数为距离，确定下一试探桶单元  
+ [ hash(key) + 1^2 ] % M  
+ [ hash(key) + 2^2 ] % M  
+ [ hash(key) + 3^2 ] % M  
+ [ hash(key) + 4^2 ] % M  
+ [ hash(key) + 5^2 ] % M  

### 利弊  
利：缓解数据聚集  
弊：破坏局部性，I/O激增  
&emsp;&emsp;有时不能及时检测出空桶  
`当 M 为合数时，n^2 % M 可能的取值**必然**少于 M / 2 种`  
`当 M 为素数时，n^2 % M 可能的取值**恰好**等于 M / 2 种，恰有查找链的前 M / 2项取遍`
>`定理：若M是素数，且λ<=0.5，就一定能够找出，否则不见得。`  


## 双向平放试探  
自冲突位置起，依次向后试探  
+ [ hash(key) + 1^2 ] % M  
+ [ hash(key) - 1^2 ] % M  
+ [ hash(key) + 2^2 ] % M  
+ [ hash(key) - 2^2 ] % M  
+ [ hash(key) + 3^2 ] % M  
+ [ hash(key) - 3^2 ] % M  
>正向和逆向的子查找链，各包含 M/2 个互异的桶 ***仅对4的模余为3有效***  

## 4k+3  
表长取做素数 M = 4 * k + 3， 必然可以保证查找链的前 M 互异

## 双平方定理 two-square theorem of Fermat  
任一素数P可以表示为一对整数的平方和，当且仅当
>P % 4 = 1  


# 桶排序 / 计数排序 O(max(n, M)) ~ O(n)  

>字母排序问题 / 大量重复元素排序

## 桶排序  

+ 分配(distribution)：遍历输入基,插入桶中
## 计数排序  
+ 将累计值与统计值相加就是次序

